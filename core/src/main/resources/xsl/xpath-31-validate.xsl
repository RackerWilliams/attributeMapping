<?xml version="1.0" encoding="UTF-8"?>
<!--
   xpath-31-validate.xsl

   Given a mapping policy in XML this transform is responsible for scanning
   all XPaths and returning a list of errors associated with them.

   Errors may include:

   1. XPath syntax errors.
   2. The use of blocked functions as defined in xpath-31-rules.xml
   3. The use of higher order functions.

   The error report is given in an XML document of the following form:

   <errors
   xmlns="http://docs.rackspace.com/identity/api/ext/MappingRules">
     <error type="ERROR_TYPE" msg="Message" value="targetValue"
            inXPath="The original XPath"/>
   </errors>


   The value attribute is optional and denotes the target of the error
   (for example, the name of the blocked function).  All other
   attributes are required.

   An empty root element denotes that there are no errors.

   Copyright 2018 Rackspace US, Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
-->
<xsl:transform xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:mapping="http://docs.rackspace.com/identity/api/ext/MappingRules"
    xmlns="http://docs.rackspace.com/identity/api/ext/MappingRules"
    xmlns:merror="http://docs.rackspace.com/identity/api/ext/MappingRules/errors"
    xmlns:err="http://www.w3.org/2005/xqt-errors"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:map="http://www.w3.org/2005/xpath-functions/map"
    xmlns:fn="http://www.w3.org/2005/xpath-functions"
    xmlns:q="xpath-31-parse"
    xmlns:p="XPath31Parse"
    exclude-result-prefixes="xs merror err xsi map p mapping fn"
    version="3.0">

    <xsl:output method="xml"/>

    <xsl:mode on-no-match="shallow-skip"/>
    <xsl:mode name="validate-xpath" on-no-match="shallow-skip"/>

    <!--
        Import the XPath 3.1 parser generated via REx.

        This is the XSLT version of the XPath 3.1 parser which defines
        the q:parse-XPath function.
    -->
    <xsl:import href="xpath-31-parse.xsl"/>


    <!--
        Import xpathRules as defixed by xpath-31-rules.xml.
    -->
    <xsl:import href="xpath-31-rules.xsl"/>

    <!--
        ERRORS : These are thrown / handled internally.
    -->
    <xsl:variable name="MISSING_PREFIX" as="xs:QName" select="QName('http://docs.rackspace.com/identity/api/ext/MappingRules/errors','MISSING_PREFIX')"/>

    <xsl:variable name="root" as="element()" select="/mapping:mapping"/>

    <!--
        All in scope namespaces: recall that for simplicity sake we
        only check the root for namespaces.
    -->
    <xsl:variable name="inScopeNS" as="map(xs:string, xs:anyURI)"
                  select="map:merge((
                          $commonNS,
                          for $p in in-scope-prefixes($root)[. != '']
                            return map:entry($p, namespace-uri-for-prefix($p, $root))
                          ),
                          map {
                          'duplicates' : 'use-last'
                          })
                          "/>

    <!--
        Override the main template...
    -->
    <xsl:template name="main" match="/">
        <errors>
            <xsl:apply-templates/>
        </errors>
    </xsl:template>

    <!--
        The templates in the default (no name) mode, select XPaths
        for processing.
    -->

    <xsl:template match="mapping:attribute/@path">
        <xsl:sequence select="mapping:validate-xpath(.)"/>
    </xsl:template>

    <xsl:template match="mapping:local//mapping:*[@value and matches(@value,'\{Pt')]">
        <xsl:sequence select="for $group in analyze-string(@value, '\{Pts?\((.*?)\)\}', 'ms')//fn:group
                              return mapping:validate-xpath(string($group))"/>
    </xsl:template>

    <xsl:function name="mapping:validate-xpath" as="node()*">
        <xsl:param name="xpath" as="xs:string"/>

        <!--
            We are integrated with two XPath 3.1 parsers, both
            generated by REx.

            p:parse-XPath  : This is the Java based parser, it is
                             supper fast, but needs to be registered
                             with the Saxon runtime.

            q:parse-XPath  : This is the XSLT based parser, much, much,
                             much slower but because it is native to
                             XSLT, good for debugging with Oxygen.

            Both parsers work in exactly the same way and can be
            dropins for one another.

            The strategy here is to check if p:parse-XPath is
            available and use it if it is. If it's not we fall back to
            q:parse-XPath.  Because nine times out of ten we want to
            be using p:parse-XPath we warn when we are using
            q:parse-XPath.
        -->
        <xsl:message use-when="not(function-available('p:parse-XPath'))">[WARNING] !!!! Using SLOW XPath 3.1 parser !!!!</xsl:message>
        <xsl:apply-templates mode="validate-xpath"
            _select="{if (function-available('p:parse-XPath')) then 'p' else 'q'}:parse-XPath($xpath)">
            <xsl:with-param name="xpath" as="xs:string" tunnel="yes" select="$xpath"/>
        </xsl:apply-templates>
    </xsl:function>

    <!--
        The templates in the validate-xpath mode, scan XPath
        expression trees and output errors.
    -->
    <xsl:template match="(FunctionCall | NamedFunctionRef)/FunctionEQName" mode="validate-xpath">
        <xsl:param name="xpath" as="xs:string" tunnel="yes" />
        <xsl:sequence select="mapping:validate-function-name($xpath, .)"/>
    </xsl:template>

    <xsl:template match="InlineFunctionExpr" mode="validate-xpath">
        <xsl:param name="xpath" as="xs:string" tunnel="yes"/>
        <error type="FORBIDDEN_INLINE_FUNCTION" msg="Inline Functions are not allowed!"
               inXPath="{$xpath}"/>
    </xsl:template>

    <xsl:template match="ERROR" mode="validate-xpath">
        <xsl:param name="xpath" as="xs:string" tunnel="yes"/>
        <error type="SYNTAX" msg="{.}"
            inXPath="{$xpath}"/>
    </xsl:template>

    <!--
        Checks to see if a function name should be blocked.
    -->
    <xsl:function name="mapping:validate-function-name" as="node()*">
        <xsl:param name="xpath" as="xs:string"/>
        <xsl:param name="funName" as="xs:string"/>
        <xsl:try>
            <xsl:variable name="funQN" as="xs:QName">
                <xsl:choose>
                    <xsl:when test="starts-with($funName,'Q{')">
                        <xsl:analyze-string select="$funName" regex="^Q\{{([^{{}}]*)\}}(.*)" flags="s">
                            <xsl:matching-substring>
                                <xsl:sequence select="QName(normalize-space(regex-group(1)), normalize-space(regex-group(2)))"/>
                            </xsl:matching-substring>
                        </xsl:analyze-string>
                    </xsl:when>
                    <xsl:when test="not(contains($funName,':'))">
                        <xsl:sequence select="QName($commonNS('fn'), normalize-space($funName))"/>
                    </xsl:when>
                    <xsl:otherwise>
                        <xsl:variable name="prefix" as="xs:string" select="normalize-space(substring-before($funName, ':'))"/>
                        <xsl:if test="not(map:contains($inScopeNS,$prefix))" expand-text="yes">
                            <xsl:sequence select="error($MISSING_PREFIX,'',$prefix)"/>
                        </xsl:if>
                        <xsl:sequence select="QName($inScopeNS($prefix),normalize-space($funName))"/>
                    </xsl:otherwise>
                </xsl:choose>
            </xsl:variable>
            <xsl:if test="map:contains($blockFuns, $funQN) or not(map:contains($legalFunNS, namespace-uri-from-QName($funQN)))">
                <error type="FORBIDDEN_FUNCTION"
                       msg="The function '{$funName}' is not allowed!"
                       value="{$funName}"
                       inXPath="{$xpath}"/>
            </xsl:if>
            <xsl:catch errors="merror:MISSING_PREFIX">
                <error type="MISSING_PREFIX"
                       msg="The prefix '{$err:value}' is not defined in the root mapping."
                       value="{$err:value}"
                       inXPath="{$xpath}"/>
            </xsl:catch>
        </xsl:try>
    </xsl:function>
</xsl:transform>
